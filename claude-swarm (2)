#!/usr/bin/env bash
# claude-swarm: Spawn N AI CLI instances in git worktrees inside tmux
# Usage: claude-swarm [-n NUM] [-s SESSION] [-b BASE_BRANCH] [-t claude|gemini|codex]
set -euo pipefail

# â”€â”€ Defaults â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NUM=4
SESSION="claude-swarm"
BASE_BRANCH=""          # empty = current branch
WORKTREE_PREFIX=".wt"   # worktrees live at .wt-1, .wt-2, â€¦
CLI_TYPE="claude"       # AI CLI to launch: claude, gemini, or codex
ADD_MODE=0              # 1 = append workers to existing session

# â”€â”€ Usage-limit resume settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RESUME_BUFFER_SECS=120  # Extra buffer (2 min) added after stated wait time
MONITOR_INTERVAL=30     # How often (secs) to check panes for usage-limit errors
SWARM_LOG=""            # Set after SESSION is known (uses /tmp/claude-swarm-<session>.log)

# â”€â”€ Parse args â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
usage() {
  echo "Usage: $(basename "$0") [-n NUM] [-s SESSION] [-b BRANCH] [-t claude|gemini|codex] [-a]"
  echo "  -n NUM     Number of AI instances   (default: $NUM)"
  echo "  -s SESSION tmux session name        (default: $SESSION)"
  echo "  -b BRANCH  Base branch for worktrees (default: current branch)"
  echo "  -t TYPE    AI CLI to use: claude|gemini|codex (default: $CLI_TYPE)"
  echo "  -a         Add workers to an existing session instead of restarting"
  exit 1
}

while getopts ":n:s:b:t:ah" opt; do
  case $opt in
    n) NUM="$OPTARG" ;;
    s) SESSION="$OPTARG" ;;
    b) BASE_BRANCH="$OPTARG" ;;
    t) CLI_TYPE="$OPTARG" ;;
    a) ADD_MODE=1 ;;
    h) usage ;;
    *) echo "Unknown option: -$OPTARG"; usage ;;
  esac
done

# â”€â”€ Sanity checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if ! git rev-parse --git-dir &>/dev/null; then
  echo "âŒ  Not inside a git repository." >&2; exit 1
fi

if ! command -v tmux &>/dev/null; then
  echo "âŒ  tmux not found. Install it first." >&2; exit 1
fi

case "$CLI_TYPE" in
  claude|gemini|codex) ;;
  *) echo "âŒ  Unknown CLI type: '$CLI_TYPE'. Use claude, gemini, or codex." >&2; exit 1 ;;
esac

if ! command -v "$CLI_TYPE" &>/dev/null; then
  echo "âŒ  $CLI_TYPE not found. Install it first." >&2; exit 1
fi

re='^[1-9][0-9]*$'
if ! [[ $NUM =~ $re ]]; then
  echo "âŒ  -n must be a positive integer." >&2; exit 1
fi

# â”€â”€ Resolve repo info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
REPO_ROOT=$(git rev-parse --show-toplevel)
[[ -z "$BASE_BRANCH" ]] && BASE_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse HEAD)
SWARM_LOG="/tmp/claude-swarm-${SESSION}.log"

echo "ğŸŒ³  Repo   : $REPO_ROOT"
echo "ğŸŒ¿  Branch : $BASE_BRANCH"
echo "ğŸ¤–  Instances: $NUM  (CLI: $CLI_TYPE)"
echo "ğŸ“º  Session : $SESSION"
echo "ğŸ“‹  Log     : $SWARM_LOG"
echo ""

# â”€â”€ Add mode: append workers to an existing session â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [[ $ADD_MODE -eq 1 ]]; then
  if ! tmux has-session -t "$SESSION" 2>/dev/null; then
    echo "âŒ  Session '$SESSION' not found. Start a swarm first (without -a)." >&2
    exit 1
  fi

  # Find the highest existing window index
  MAX_WIN=$(tmux list-windows -t "$SESSION" -F "#{window_index}" | sort -n | tail -1)
  START_IDX=$((MAX_WIN + 1))

  NEW_DIRS=()
  cleanup_new() {
    echo ""
    echo "ğŸ§¹  Cleaning up new worktreesâ€¦"
    for dir in "${NEW_DIRS[@]}"; do
      [[ -d "$dir" ]] && git worktree remove --force "$dir" 2>/dev/null || true
    done
    git worktree prune 2>/dev/null || true
  }
  trap cleanup_new EXIT

  for i in $(seq "$START_IDX" $((START_IDX + NUM - 1))); do
    WT_DIR="$REPO_ROOT/${WORKTREE_PREFIX}-${i}"
    WT_BRANCH="swarm/${BASE_BRANCH}/worker-${i}"
    [[ -d "$WT_DIR" ]] && git worktree remove --force "$WT_DIR" 2>/dev/null || true
    git branch -D "$WT_BRANCH" 2>/dev/null || true
    git worktree add -b "$WT_BRANCH" "$WT_DIR" "$BASE_BRANCH" -q
    NEW_DIRS+=("$WT_DIR")
    echo "âœ…  Worktree ${i} â†’ $WT_DIR  (branch: $WT_BRANCH)"
  done

  echo ""
  for i in $(seq "$START_IDX" $((START_IDX + NUM - 1))); do
    WT_DIR="$REPO_ROOT/${WORKTREE_PREFIX}-${i}"
    tmux new-window -t "$SESSION" -c "$WT_DIR" -n "worker-${i}"
    tmux send-keys -t "${SESSION}:${i}" "$CLI_TYPE" Enter
  done

  tmux select-window -t "${SESSION}:${START_IDX}"
  trap - EXIT

  echo "âœ…  Added $NUM ${CLI_TYPE} worker(s) to session '$SESSION'."
  echo "    Attach with: tmux attach -t '$SESSION'"
  exit 0
fi

# â”€â”€ Usage-limit detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Returns 0 (true) if the pane content contains an API usage-limit error
has_usage_limit_error() {
  local content="$1"
  echo "$content" | grep -qiE \
    "exceeded your usage limit|usage limits.{0,60}try again after|rate limit.{0,60}retry after"
}

# Parses wait duration from error text; prints total seconds (without buffer).
# Tries the exact UTC timestamp first, then the relative duration, then defaults to 1 hour.
extract_wait_secs() {
  local content="$1"

  # Primary: "after HH:MM UTC" â€” sleep until the exact stated wall-clock time
  local utc_time
  utc_time=$(echo "$content" | grep -oiE 'after [0-9]+:[0-9]+ UTC' \
             | grep -oE '[0-9]+:[0-9]+' | head -1)
  if [[ -n "$utc_time" ]]; then
    local target_h target_m now_epoch target_epoch
    target_h=$(echo "$utc_time" | cut -d: -f1)
    target_m=$(echo "$utc_time" | cut -d: -f2)
    now_epoch=$(date -u +%s)
    target_epoch=$(date -u -d "today ${target_h}:${target_m}:00" +%s 2>/dev/null || echo 0)
    if [[ $target_epoch -gt 0 && $target_epoch -le $now_epoch ]]; then
      target_epoch=$(( target_epoch + 86400 ))  # already passed â†’ next day
    fi
    if [[ $target_epoch -gt 0 ]]; then
      echo $(( target_epoch - now_epoch ))
      return
    fi
  fi

  # Fallback: "in X hours Y minutes"
  local hours=0 mins=0
  local h_match
  h_match=$(echo "$content" | grep -oiE 'in [0-9]+ hours?' | grep -oE '[0-9]+' | head -1)
  [[ -n "$h_match" ]] && hours="$h_match"

  if [[ $hours -gt 0 ]]; then
    local m_match
    m_match=$(echo "$content" | grep -oiE '[0-9]+ minutes?' | grep -oE '[0-9]+' | head -1)
    [[ -n "$m_match" ]] && mins="$m_match"
  fi

  if [[ $hours -gt 0 || $mins -gt 0 ]]; then
    echo $(( hours * 3600 + mins * 60 ))
    return
  fi

  echo 3600  # default fallback: 1 hour
}

# Background monitor: watches one tmux window for usage-limit errors and
# automatically resumes with `<CLI_TYPE> --continue` after the wait expires.
monitor_usage_limit() {
  local window="$1"       # tmux window index (1-based)
  local worker_num="$2"   # human label used in window name / log
  local detected=0

  while tmux has-session -t "$SESSION" 2>/dev/null; do
    sleep "$MONITOR_INTERVAL"

    if ! tmux has-session -t "$SESSION" 2>/dev/null; then break; fi

    local content
    content=$(tmux capture-pane -t "${SESSION}:${window}" -p 2>/dev/null) || break

    if [[ $detected -eq 0 ]] && has_usage_limit_error "$content"; then
      detected=1

      local wait_secs total_secs
      wait_secs=$(extract_wait_secs "$content")
      total_secs=$(( wait_secs + RESUME_BUFFER_SECS ))

      local display_h display_m
      display_h=$(( total_secs / 3600 ))
      display_m=$(( (total_secs % 3600) / 60 ))

      printf '%s [worker-%s] API usage limit hit. Resuming in %dh %dm.\n' \
        "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" "$worker_num" "$display_h" "$display_m" \
        | tee -a "$SWARM_LOG"

      tmux rename-window -t "${SESSION}:${window}" \
        "w${worker_num}[wait ${display_h}h${display_m}m]" 2>/dev/null || true

      sleep "$total_secs"

      if tmux has-session -t "$SESSION" 2>/dev/null; then
        printf '%s [worker-%s] Resuming with %s --continue.\n' \
          "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" "$worker_num" "$CLI_TYPE" \
          | tee -a "$SWARM_LOG"

        tmux send-keys -t "${SESSION}:${window}" "$CLI_TYPE --continue" Enter
        tmux rename-window -t "${SESSION}:${window}" "worker-${worker_num}" 2>/dev/null || true
        detected=0  # reset so future limit hits are detected
      fi
    fi
  done
}

# â”€â”€ Kill existing session (clean restart) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if tmux has-session -t "$SESSION" 2>/dev/null; then
  echo "âš ï¸   Session '$SESSION' already exists â€” killing it."
  tmux kill-session -t "$SESSION"
fi

# â”€â”€ Create worktrees â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
WORKTREE_DIRS=()
MONITOR_PIDS=()

cleanup() {
  echo ""
  echo "ğŸ”´  Stopping pane monitorsâ€¦"
  for pid in "${MONITOR_PIDS[@]}"; do
    kill "$pid" 2>/dev/null || true
  done

  echo "ğŸ§¹  Cleaning up worktreesâ€¦"
  for dir in "${WORKTREE_DIRS[@]}"; do
    if [[ -d "$dir" ]]; then
      git worktree remove --force "$dir" 2>/dev/null || true
    fi
  done
  git worktree prune 2>/dev/null || true
}
trap cleanup EXIT

for i in $(seq 1 "$NUM"); do
  WT_DIR="$REPO_ROOT/${WORKTREE_PREFIX}-${i}"
  WT_BRANCH="swarm/${BASE_BRANCH}/worker-${i}"

  # Remove stale worktree/branch if they exist
  if [[ -d "$WT_DIR" ]]; then
    git worktree remove --force "$WT_DIR" 2>/dev/null || true
  fi
  git branch -D "$WT_BRANCH" 2>/dev/null || true

  git worktree add -b "$WT_BRANCH" "$WT_DIR" "$BASE_BRANCH" -q
  WORKTREE_DIRS+=("$WT_DIR")
  echo "âœ…  Worktree $i â†’ $WT_DIR  (branch: $WT_BRANCH)"
done

echo ""
echo "ğŸš€  Launching tmux sessionâ€¦"

# â”€â”€ Build tmux session â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
STATUS_BAR="#[bg=colour235,fg=colour245] Swarm: ${NUM} workers  \
#[fg=colour39]Alt+1-9#[fg=colour245]:switch  \
#[fg=colour39]Ctrl+b +#[fg=colour245]:add worker  \
#[fg=colour39]Ctrl+b d#[fg=colour245]:detach  \
#[fg=colour39]Ctrl+b x#[fg=colour245]:kill tab  \
#[fg=colour39]Ctrl+b [#[fg=colour245]:scroll  \
#[fg=colour39]q#[fg=colour245]:exit scroll"

# Start session with first window
tmux new-session -d -s "$SESSION" -c "${WORKTREE_DIRS[0]}" -x 220 -y 50

# Configure status bar
tmux set-option -t "$SESSION" status on
tmux set-option -t "$SESSION" status-position bottom
tmux set-option -t "$SESSION" status-style "bg=colour235,fg=colour245"
tmux set-option -t "$SESSION" status-left "#[bg=colour33,fg=colour15,bold] ğŸ¤– SWARM (${CLI_TYPE}) #[bg=colour235] "
tmux set-option -t "$SESSION" status-left-length 30
tmux set-option -t "$SESSION" status-right "$STATUS_BAR"
tmux set-option -t "$SESSION" status-right-length 120
tmux set-option -t "$SESSION" window-status-format "#[fg=colour245] #I:#W "
tmux set-option -t "$SESSION" window-status-current-format "#[bg=colour33,fg=colour15,bold] #I:#W "

# Bind Alt+number for quick window switching
for n in $(seq 1 9); do
  tmux bind-key -t "$SESSION" -n "M-${n}" select-window -t "${n}"  2>/dev/null || \
  tmux bind-key -n "M-${n}" select-window -t "${n}"
done

# Bind Alt++ to add a new worker on the fly (values baked in at session-creation time)
ADD_ONE="idx=\$(tmux list-windows -t '${SESSION}' -F '#{window_index}' | sort -n | tail -1); \
idx=\$((idx+1)); \
wt='${REPO_ROOT}/${WORKTREE_PREFIX}-'\$idx; \
br='swarm/${BASE_BRANCH}/worker-'\$idx; \
git -C '${REPO_ROOT}' worktree add -b \"\$br\" \"\$wt\" '${BASE_BRANCH}' -q && \
tmux new-window -t '${SESSION}' -c \"\$wt\" -n \"worker-\$idx\" && \
tmux send-keys -t '${SESSION}':\$idx '${CLI_TYPE}' Enter && \
tmux display-message \"âœ… Worker \$idx added\""
tmux bind-key "+" run-shell "$ADD_ONE"

# Rename first window and launch AI CLI
tmux rename-window -t "${SESSION}:1" "worker-1"
tmux send-keys -t "${SESSION}:1" "$CLI_TYPE" Enter

# Start usage-limit monitor for window 1
monitor_usage_limit 1 1 &
MONITOR_PIDS+=($!)

# Create remaining windows
for i in $(seq 2 "$NUM"); do
  tmux new-window -t "$SESSION" -c "${WORKTREE_DIRS[$((i-1))]}" -n "worker-${i}"
  tmux send-keys -t "${SESSION}:${i}" "$CLI_TYPE" Enter

  # Start usage-limit monitor for this window
  monitor_usage_limit "$i" "$i" &
  MONITOR_PIDS+=($!)
done

# Go back to window 1
tmux select-window -t "${SESSION}:1"

# â”€â”€ Attach â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo "âœ…  All $NUM ${CLI_TYPE} instances launched!"
echo "ğŸ”  Usage-limit monitors active (log: $SWARM_LOG)"
echo "ğŸ“  Attaching to session '$SESSION'â€¦"
echo "    Detach anytime with: Ctrl+b  d"
echo ""

# Disable the EXIT trap while attached (user manually cleans up after detach)
trap - EXIT

tmux attach-session -t "$SESSION"

# â”€â”€ Post-detach: stop monitors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo ""
echo "ğŸ”´  Stopping pane monitorsâ€¦"
for pid in "${MONITOR_PIDS[@]}"; do
  kill "$pid" 2>/dev/null || true
done

# â”€â”€ Post-detach cleanup prompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo ""
read -rp "ğŸ§¹  Remove worktrees and swarm branches? [Y/n] " answer
answer="${answer:-Y}"
if [[ "$answer" =~ ^[Yy]$ ]]; then
  for dir in "${WORKTREE_DIRS[@]}"; do
    branch=$(git -C "$dir" symbolic-ref --short HEAD 2>/dev/null || true)
    git worktree remove --force "$dir" 2>/dev/null || true
    [[ -n "$branch" ]] && git branch -D "$branch" 2>/dev/null || true
  done
  git worktree prune
  echo "âœ…  Cleaned up."
else
  echo "â„¹ï¸   Worktrees kept. Remove manually with: git worktree remove <path>"
fi
